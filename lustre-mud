#!/usr/bin/bash

set -e
set -x

TUTBIN=/admin/tut/bin/updates
#TUTBIN=/root/update/tut
PDSH="pdsh -t2 -u60"
PDSH_LONG="pdsh -t2"
NBD_SIZE="30G"
#DRYRUN="echo"
DRYRUN=""

## Principles of operation
# 1. Work in stages; Altmgmt, then Primgmt, then Sample, then mds, then oss
# 2. Direct all work from primgmt via pdsh
# 3. Track state of the set of nodes currently being worked,
# rather than trying to identify and track state changes
# in the entire cluster.
# 4. Bail out when a stage fails, let admin fix/finish by hand
# 5. All state changes prefixed with $DRYRUN so they can be echoed instead of executed

######## Overall Process #######
## for my node in altmgmt primgmt; do
##   update $node
##   reboot $node
##   verify $node
##
## update image
##
## standby sample-node
## reboot sample-node
## verify sample-node
## unstandby sample-node
################################

function error {
	echo "$(date --rfc-3339=seconds) $0: ERROR $*" >&2
}

function log {
	echo "$(date --rfc-3339=seconds) $0: $*"
}

if ! nodeattr pacemaker ; then
	error "only for use on Lustre clusters"
	exit 1
fi

if [ -z $(nodeattr -q mds) ] ; then
	error "only for use on Lustre clusters"
	exit 1
fi

if ! nodeattr primgmt ; then
	error "must be run from primgmt"
	exit 1
fi

if [ $(id -u) -ne 0 ]; then
	error "must be run as root"
	exit 1
fi

desired=$(basename $(realpath /repo/toss/3/current) | sed s/toss-release-//)
desired_kernel=$(ls /repo/toss/3/current/$(arch)/kernel-3*rpm | tail -n1 | xargs basename | sed s/kernel-// | sed s/.rpm//)
use_iscsi=$(nodeattr -q 'mds&&iscsi')

function actual_toss_version {
	local funcname="actual_toss_version"
	local node=$1

	if [ -z "$node" ]; then
		error "$funcname: missing argument node"
		exit 2
	fi

	local actual=$(${PDSH} -N -w e${node} distro_version | awk '{print $NF}')

	echo $actual
}

function running_kernel {
	local funcname="running_kernel"
	local node=$1

	if [ -z "$node" ]; then
		error "$funcname: missing argument node"
		exit 2
	fi

	echo $(${PDSH} -N -w e${node} uname -r)
}

function update_required {
	local funcname="update_required"
	local actual=$1
	local desired=$2

	if [ -z "$actual" ]; then
		error "$funcname: missing argument actual"
		exit 2
	fi

	if [ -z "$desired" ]; then
		error "$funcname: missing argument desired"
		exit 2
	fi

	# update from release candidates, even though
	# rpmdev-vercmp says they are newer than the
	# final release.
	if [[ "$actual" =~ rc[0-9]$ ]]; then
		echo "yes"
		return
	fi

	rpmdev-vercmp "${actual}" "${desired}" >/dev/null
	local rc=$?
	if [ $rc -eq 12 ]; then
		# desired is newer
		echo "yes"
	else
		echo "no"
	fi
}

function want_toss_update {
	local funcname="want_toss_update"
	local node=$1
	local desired=$2

	if [ -z "$node" ]; then
		error "$funcname: missing argument node"
		exit 2
	fi

	if [ -z "$desired" ]; then
		error "$funcname: missing argument desired"
		exit 2
	fi

	actual=$(actual_toss_version ${node})

	update_required $actual $desired
}

function want_reboot {
	local funcname="want_reboot"
	local node=$1
	local desired=$2

	if [ -z "$node" ]; then
		error "$funcname: missing argument node"
		exit 2
	fi

	if [ -z "$desired" ]; then
		error "$funcname: missing argument desired"
		exit 2
	fi

	local running=$(running_kernel $node)
	update_required $running $desired
}

function update_mgmt_node {
	local funcname="update_mgmt_node"
	local node=$1
	local version=$2

	if [ -z "$node" ]; then
		error "$funcname: missing argument node"
		exit 2
	fi

	if [ -z "$version" ]; then
		error "$funcname: missing argument version"
		exit 2
	fi

	log "UPDATING node $node to $version"
	local tut=${TUTBIN}/${version}

	if [ -f $tut ]; then
		# stop pacemaker first as it may be updated
		$DRYRUN ${PDSH_LONG} -w $node pcs cluster kill
		$DRYRUN ${PDSH_LONG} -w $node bash -x $tut
		local rc=$?
		if [ $rc -ne 0 ]; then
			error "$tut update script failed on node $node."
			exit 4
		fi
		$DRYRUN ${PDSH_LONG} -w $node cfagent -K
		$DRYRUN ${PDSH_LONG} -w $node systemctl start pacemaker
		log "${funcname}: waiting for pacemaker to re-detect cluster state"
		sleep 180
	else
		error "$tut update script is not executable."
		exit 4
	fi
}

function reboot_node {
	local funcname="reboot_node"
	local node=$1

	if [ -z "$node" ]; then
		error "$funcname: missing argument node"
		exit 2
	fi

	log "REBOOTING node $node"
	if nodeattr $node pacemaker ; then
		$DRYRUN ${PDSH} -w e${node} $DRYRUN pcs cluster kill
	fi

	if nodeattr $node mgmt ; then
		$DRYRUN ${PDSH} -w e${node} $DRYRUN umount -a -l -t nfs
	fi
	$DRYRUN ${PDSH} -w e${node} reboot
}

# Wait until the specified host(s) are 'up' per whatsup and multi-user.target was reached
# timeout is in seconds
function wait_for_hostlist_up {
	local funcname="wait_for_hostlist_up"
	local hostlist=$1
	local timeout=$2

	if [ -z "$hostlist" ]; then
		error "$funcname: missing argument hostlist"
		exit 2
	fi

	if [ -z "$timeout" ]; then
		error "$funcname: missing argument timeout"
		exit 2
	fi

	local start=$(date +%s)
	local end=$((start + timeout))

	local are_up=""
	while [ $(date +%s) -lt $end ]; do
		sleep 1
		if ! whatsup -u $hostlist | fgrep -q -w $hostlist ; then
			continue
		fi

		local current_status=$($PDSH -N -w e${hostlist} systemctl status multi-user.target | awk '/Active:/ {print $2}' | uniq)
		if [ -z "$current_status" ]; then
			# node down
			continue
		fi

		if [ "active" = "$current_status" ]; then
			are_up="yes"
			break
		fi
	done

	if [ "$are_up" != "yes" ]; then
		error "$hostlist not up after $timeout seconds"
	fi
}

function update_mgmt_nodes {
	local funcname="update_mgmt_nodes"
	local desired_toss=$1
	local desired_kernel=$2

	if [ -z "$desired_toss" ]; then
		error "$funcname: missing argument desired_toss"
		exit 2
	fi

	if [ -z "$desired_kernel" ]; then
		error "$funcname: missing argument desired_kernel"
		exit 2
	fi

	altmgmt=$(nodeattr -q altmgmt)
	if [ -n "$altmgmt" ]; then
		if [ $(hostlist --count $altmgmt) -gt 1 ]; then
			error "unable to correctly handle clusters with >1 altmgmt node.  Exiting."
			exit 2
		fi
	fi

	for gender in altmgmt primgmt; do
		log "Checking $gender nodes"

		node=$(nodeattr -q $gender)
		if [ -n "$node" ]; then
			toss_update_required=$(want_toss_update ${node} ${desired_toss})
			if [ $toss_update_required = "yes" ]; then
				echo $0: $node: $gender toss_update $toss_update_required from $(actual_toss_version ${node}) to $desired_toss
				update_mgmt_node $node ${desired_toss}
			else
				log "$node: $gender no update reqd, already running toss $desired_toss"
			fi

			reboot_required=$(want_reboot ${node} ${desired_kernel})
			if [ $reboot_required = "yes" ]; then
				echo $node: $gender reboot $reboot_required from $(running_kernel ${node}) to $desired_kernel
				reboot_node $node
				wait_for_hostlist_up $node 300
			else
				log "$node: $gender no reboot reqd, already running kernel $desired_kernel"
			fi
		else
			log "No nodes with gender $gender"
		fi
	done
}

function get_image_name {
	local funcname="get_image_name"
	local iscsi_image_count=$(nodeattr -V iscsi | sort -u | wc -l)
	local nfsroot_image_count=$(nodeattr -V nfsroot | sort -u | wc -l)

	local imgname=""
	if [ -n "$use_iscsi" ]; then
		if [ $iscsi_image_count -ne 1 ]; then
			error "$funcname: script only handles clusters with 1 iscsi image"
			exit 2
		fi
		imgname=$(nodeattr -V iscsi | head -n1)
	else
		if [ $nfsroot_image_count -ne 1 ]; then
			error "$funcname: script only handles clusters with 1 nfsroot image"
			exit 2
		fi
		imgname=$(nodeattr -V nfsroot | head -n1 | sed -E 's/[0-9]+\.[0-9]+\.[0-9]+\.[0-9]+://')
		imgname=$(echo $imgname | sed "s/.$(arch)//")
	fi

	echo $imgname
}

function is_image_ready {
	local desired_toss=$1

	if [ -z "$desired_toss" ]; then
		error "$funcname: missing argument desired_toss"
		exit 2
	fi

	local image_name=$(get_image_name)
	local image_path=/tftpboot/images/${image_name}.$(arch)
	local image_ready="no"

	if [ -n "$use_iscsi" ]; then
		image_path=/tftpboot/images/${image_name}.$(arch).latest
		if [ $(losetup | grep -c -w $image_name) -gt 0 ]; then
			error "$funcname: image $image_name already loopback mounted; umount and retry"
			exit 2
		fi
	fi

	if [ -h $image_path ]; then
		local mount_path=$image_path
		local real_image_name=$(basename $(realpath $image_path))
		local mounted=""

		if [ -n "$use_iscsi" ]; then
			mount_path=/mnt/${image_name}
			mkdir -p $mount_path
			if mount -o loop,ro $image_path $mount_path; then
				mounted=yes
			fi
		fi

		if [ -d ${mount_path}/etc ]; then
			# Check TOSS version and distro_diff
			local image_version=$(chroot $mount_path distro_version | sed 's/toss //')
			if [ $image_version = $desired_toss ]; then
				local image_diff=$(chroot $mount_path distro_diff | wc -l)
				if [ $image_diff -lt 30 ]; then
					image_ready="yes"
				fi
			fi

			# Check that it's been activated
			if [ -n "$use_iscsi" ]; then
				if [ ! -f /tftpboot/images/.$real_image_name ]; then
					image_ready="no"
				fi
			else
				if [ ! -f ${image_path}/etc/passwd ]; then
					image_ready="no"
				fi
			fi
		fi

		if [ "$mounted" = "yes" ]; then
			umount $mount_path
		fi
	fi

	echo $image_ready
}

function create_image {
	local funcname="create_image"
	local desired_toss=$1

	if [ -z "$desired_toss" ]; then
		error "$funcname: missing argument desired_toss"
		exit 2
	fi

	if [ $(arch) != "x86_64" ]; then
		error "$funcname: script untested with arch $(arch)"
		exit 2
	fi

	echo $0: create_image: creating image version $desired_toss
	local image_name=$(get_image_name)

	local lustre_group="lustre_2.10"
	nodeattr lustre212 && lustre_group="lustre_2.12"
	nodeattr lustre28 && lustre_group="lustre_2.8"

	local nbd_size_opt=""
	if [ -n "$use_iscsi" ]; then
		nbd_size_opt="-b ${NBD_SIZE}"
	fi

	$DRYRUN create_yum_image -i ${image_name} ${nbd_size_opt} base netroot $(arch) ${lustre_group}

	local nbd_size_opt=""
	if [ -n "$use_iscsi" ]; then
		$DRYRUN /tftpboot/scripts/activate_iscsi -i ${image_name}
	else
		$DRYRUN /tftpboot/scripts/activate_image -i ${image_name} -l
	fi

	if [ -z "$DRYRUN" -a $(is_image_ready $desired) = "no" ]; then
		error "$funcname: failed to validate new image"
		exit 2
	fi
}

function update_firmware {
	local funcname="update_firmware"
	echo $0: update_firmware: updating firmware with ib_burn_fw
	$DRYRUN $PDSH -f 128 -Av -X cfhost mount cfhost:/usr/share/ib_firmware /usr/share/ib_firmware
	$DRYRUN $PDSH -f 128 -Av /sbin/ib_burn_fw
	$DRYRUN $PDSH -f 128 -Av -X cfhost umount /usr/share/ib_firmware
}

# Wait until the specified host(s) have pools imported
# timeout is in seconds
function wait_for_zpools_imported {
	local funcname="wait_for_zpools_imported"
	local hostlist=$1
	local timeout=$2

	if [ -z "$hostlist" ]; then
		error "$funcname: missing argument hostlist"
		exit 2
	fi

	if [ -z "$timeout" ]; then
		error "$funcname: missing argument timeout"
		exit 2
	fi

	local start=$(date +%s)
	local end=$((start + timeout))

	local pools_imported=""
	while [ $(date +%s) -lt $end ]; do
		sleep 1
		local nodes_with_online=$($PDSH -w e${hostlist} 'zpool list | grep ONLINE | xargs --no-run-if-empty' | wc -l)
		if [ $nodes_with_online -eq $(hostlist -c $hostlist) ]; then
			pools_imported="yes"
			break
		fi
	done

	if [ "$pools_imported" != "yes" ]; then
		error "pools not imported from $hostlist after $timeout seconds"
	fi
}

# Wait until the specified host(s) have no pools imported
# timeout is in seconds
function wait_for_zpools_exported {
	local funcname="wait_for_zpools_exported"
	local hostlist=$1
	local timeout=$2

	if [ -z "$hostlist" ]; then
		error "$funcname: missing argument hostlist"
		exit 2
	fi

	if [ -z "$timeout" ]; then
		error "$funcname: missing argument timeout"
		exit 2
	fi

	local start=$(date +%s)
	local end=$((start + timeout))

	local pools_exported=""
	while [ $(date +%s) -lt $end ]; do
		sleep 1
		if whatsup -d $hostlist | grep -q -w $hostlist ; then
			pools_exported="yes"
			break
		fi

		if [ "no pools available" = "$($PDSH -N -w e${hostlist} zpool list)" ]; then
			pools_exported="yes"
			break
		fi
	done

	if [ "$pools_exported" != "yes" ]; then
		error "pools not exported from $hostlist after $timeout seconds"
	fi
}

function pcs_node_status {
	local funcname="pcs_node_status"
	local node=$1

	if [ -z "$node" ]; then
		error "$funcname: missing argument node"
		exit 2
	fi

	pcs status nodes | grep -w $node | awk '{print $1}'
}

function lustre_node_ready {
	local funcname="lustre_node_ready"
	local node=$1
	local desired_toss=$2
	local ready="yes"

	if [ -z "$node" ]; then
		error "$funcname: missing argument node"
		exit 2
	fi

	if [ -z "$desired_toss" ]; then
		error "$funcname: missing argument desired_toss"
		exit 2
	fi

	local new_toss_version=$(actual_toss_version $node)
	local zpool_imported=$($PDSH -w e${node} zpool list $node 2> /dev/null)
	local zpool_present=$($PDSH -w e${node} zpool import | awk '/pool:/ {print $NF}' | grep -w $node)

	if [ "$new_toss_version" != $desired_toss ]; then
		ready="no"
	fi

	if [ -z "$zpool_imported" -a "$zpool_present" != $node ]; then
		ready="no"
	fi

	echo $ready
}

function bounce_all_nodes {
	local funcname="bounce_all_nodes"
	local desired_toss=$1

	if [ -z "$desired_toss" ]; then
		error "${funcname}: missing argument desired_toss"
		exit 2
	fi

	local nodelist=$(nodeattr -q 'mds||oss')
	log "${funcname}: stopping pacemaker (and lustre)"
	$DRYRUN timeout --kill-after=10m 11m systemctl stop pacemaker

	log "${funcname}: powering off all lustre servers"
	$DRYRUN pm -g -0 'mds||oss'
	sleep 2
	if [ $(pm -g -q 'mds||oss' | awk '/off:/ {print $NF}') != $nodelist ]; then
		error "${funcname}: failed to power off nodes $nodelist, proceed manually"
		$DRYRUN exit 2
	fi

	log "${funcname}: powering on all lustre servers"
	$DRYRUN pm -g -1 'mds||oss'
	sleep 2
	if [ $(pm -g -q 'mds||oss' | awk '/on:/ {print $NF}') != $nodelist ]; then
		error "${funcname}: failed to power on nodes $nodelist, proceed manually"
		exit 2
	fi

	log "${funcname}: waiting for lustre servers to boot"
	sleep 60
	wait_for_hostlist_up $nodelist 420

	local desired_version_count=$($PDSH -w e${nodelist} distro_version | grep -w -c $desired_toss)
	local badnode_count=$($PDSH -w e${nodelist} ls /etc/badnode 2>/dev/null | wc -l)

	if [ $desired_version_count != $(hostlist -c $nodelist) ]; then
		error "${funcname}: rebooted nodes ($nodelist) not all $desired_toss, proceed manually"
		exit 2
	fi

	if [ $badnode_count != 0 ]; then
		error "${funcname}: some rebooted nodes in $nodelist have badnode, proceed manually"
		exit 2
	fi

	$DRYRUN $PDSH -w e${nodelist} "zpool import \$(hostname)"

	$DRYRUN systemctl start pacemaker

}

function bounce_sample_node {
	local funcname="bounce_sample_node"
	local desired_toss=$1

	if [ -z "$desired_toss" ]; then
		error "$funcname: missing argument desired_toss"
		exit 2
	fi

	# Could instead take highest numbered Online node from pcs node status output
	local sample_node=$(nodeattr -n oss | tail -n1)
	#local sample_node=$(nodeattr -n mds | tail -n1)
	local partner_node=$(ldev --hostname $sample_node -p)

	log "bounce_sample_node: bouncing node $sample_node to test image failover"

	local sample_node_status=$(pcs_node_status $sample_node)
	local partner_node_status=$(pcs_node_status $partner_node)

	log "sample_node: $sample_node ($sample_node_status) partner: $partner_node ($partner_node_status)"

	if [ "$partner_node_status" != "Online:" ]; then
		error "$funcname: sample node parter ($partner_node) not Online, fix and retry"
		exit 2
	fi

	$DRYRUN pcs node standby $sample_node
	$DRYRUN wait_for_zpools_exported $sample_node 300
	$DRYRUN pcs stonith fence $sample_node
	sleep 60
	wait_for_hostlist_up $sample_node 300

	if [ "$(lustre_node_ready $sample_node $desired_toss)" != "yes" ]; then
		error "$funcname: sample node ($sample_node) update failed, proceed manually"
		exit 2
	fi

	$DRYRUN pcs node unstandby $sample_node
	wait_for_zpools_imported $sample_node 300
}

#desired_mm=$(echo $desired | awk --field-separator - '{print $3}')
#desired_release=$(echo $desired | awk --field-separator - '{print $4}')
#echo desired $desired desired_mm $desired_mm desired_release $desired_release

# so our cwd doesn't disappear when we umount and restart
cd /root

# make sure we have current configs in place
$DRYRUN ${PDSH_LONG} -g mgmt cfagent -K

if [ $(is_image_ready $desired) = "no" ]; then
	create_image $desired
else
	log "Image Ready"
fi

update_mgmt_nodes $desired $desired_kernel

update_firmware

bounce_sample_node $desired

bounce_all_nodes $desired

exit 0

## Stop pacemaker and then reboot all the nodes
# pcs cluster kill
# pm -0 jet[1-21]
# pm -q jet[1-21]
# pm -1 jet[1-21]
# watch -n5 whatsup
# sudo lustre_cluster_check

## After all the nodes are up, start pacemaker; lustre should start cleanly
#sudo systemctl start pacemaker
#sleep 180
#sudo lustre_cluster_check
#sudo pcs status | less

# expected output of lustre_cluster_check:
#----------------
#lquake-MDT[0000-000F],lquake-OST[0000-0003],MGS
#----------------
#healthy pacemaker_remote_status=active
#----------------
#jet21
#----------------
#LUSTRE_SERVICES_NOT_RUNNING pacemaker_remote_status=active
